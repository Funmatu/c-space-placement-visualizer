<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics-Aware Packer: Strategy Selector</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; color: #eee; }
        
        #ui-panel {
            position: absolute; top: 10px; left: 10px; width: 360px;
            background: rgba(18, 18, 18, 0.95); padding: 20px; border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); border: 1px solid #333;
            pointer-events: auto; z-index: 100;
        }
        
        h1 { font-size: 18px; margin: 0 0 15px 0; color: #4af; text-transform: uppercase; border-bottom: 2px solid #4af; padding-bottom: 8px; letter-spacing: 1px; }
        h2 { font-size: 12px; margin: 15px 0 8px 0; color: #888; text-transform: uppercase; font-weight: bold; }

        .btn-row { display: flex; gap: 8px; margin-bottom: 15px; }
        .btn {
            flex: 1; padding: 10px; background: #2a2a2a; border: 1px solid #444; color: #ccc;
            cursor: pointer; border-radius: 4px; font-size: 11px; transition: 0.2s; text-transform: uppercase;
        }
        .btn:hover { background: #3a3a3a; border-color: #666; color: #fff; }
        .btn-primary { background: #0060b0; border-color: #0080ff; color: #fff; font-weight: bold; }
        .btn-primary:hover { background: #0070d0; box-shadow: 0 0 15px rgba(0, 100, 255, 0.4); }

        .slider-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 4px; }
        input[type=range] { width: 100%; height: 4px; background: #333; border-radius: 2px; -webkit-appearance: none; margin-bottom: 12px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #4af; border-radius: 50%; cursor: pointer; border: 2px solid #000; }

        .radio-group { display: flex; gap: 10px; margin-bottom: 15px; background: #222; padding: 8px; border-radius: 4px; border: 1px solid #333; }
        .radio-item { flex: 1; display: flex; align-items: center; font-size: 11px; cursor: pointer; color: #ccc; }
        .radio-item input { margin-right: 6px; cursor: pointer; accent-color: #4af; }

        .result-box {
            background: #111; border: 1px solid #222; border-left-width: 4px;
            padding: 10px; margin-top: 8px; font-size: 12px;
        }
        .res-header { display: flex; justify-content: space-between; margin-bottom: 4px; color: #aaa; font-weight: bold; }
        .res-row { display: flex; justify-content: space-between; align-items: center; }
        .res-val { font-family: 'Consolas', monospace; color: #fff; font-size: 13px; min-width: 80px; text-align: right; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        
        .status-ready { color: #666; }
        .status-ok { color: #4f4; text-shadow: 0 0 8px rgba(0,255,0,0.3); font-weight: bold; }
        .status-ng { color: #f44; font-weight: bold; }
        .layer-badge { font-size: 9px; padding: 2px 6px; background: #333; border-radius: 4px; color: #ddd; margin-left: 8px; border: 1px solid #555; }

        .legend { margin-top: 20px; padding-top: 10px; border-top: 1px solid #333; font-size: 11px; color: #777; }
        .legend-row { display: flex; align-items: center; gap: 10px; margin-bottom: 4px; }
        .grad-bar { width: 120px; height: 8px; background: linear-gradient(90deg, #ff0000 0%, #000000 30%, #0000ff 100%); border-radius: 3px; border:1px solid #555;}

        #loading {
            position: absolute; bottom: 30px; right: 30px; 
            font-size: 24px; font-weight: bold; color: #4af; letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            display: none; pointer-events: none; z-index: 200;
        }
    </style>
</head>
<body>
    <div id="ui-panel">
        <h1>New Method: FFT + Distance</h1>
        
        <div class="btn-row">
            <button class="btn" onclick="window.sim.sceneComplex()">Random<br>Scene</button>
            <button class="btn" onclick="window.sim.sceneTight()">Tight Gap<br>Test</button>
        </div>

        <h2>Item Dimensions</h2>
        <div class="slider-row">
            <span>Width: <span id="dispW" style="color:#fff">100</span>mm</span>
            <span>Depth: <span id="dispH" style="color:#fff">42</span>mm</span>
        </div>
        <input type="range" id="inputW" min="20" max="150" value="100" oninput="window.sim.updateSettings()">
        <input type="range" id="inputH" min="20" max="150" value="42" oninput="window.sim.updateSettings()">

        <h2>Placement Strategy</h2>
        <div class="radio-group">
            <label class="radio-item">
                <input type="radio" name="strategy" value="topLeft" checked onchange="window.sim.run()">
                Top-Left (Density)
            </label>
            <label class="radio-item">
                <input type="radio" name="strategy" value="maxSafe" onchange="window.sim.run()">
                Max Safety (Gap)
            </label>
        </div>

        <button class="btn btn-primary" style="width:100%; margin-top:5px;" onclick="window.sim.run()">RUN COMPARISON</button>

        <div style="margin-top:20px;">
            <div class="result-box" style="border-left-color: #0f0;">
                <div class="res-header"><span style="display:flex;align-items:center"><span class="dot" style="background:#0f0"></span>Geometric Search</span> <span id="time-geo">0.0ms</span></div>
                <div class="res-row">
                    <span id="stat-geo" class="status-ready">READY</span>
                    <span id="pos-geo" class="res-val">[-]</span>
                </div>
            </div>

            <div class="result-box" style="border-left-color: #0088ff;">
                <div class="res-header"><span style="display:flex;align-items:center"><span class="dot" style="background:#0088ff"></span>FFT + Distance Field</span> <span id="time-dt">0.0ms</span></div>
                <div class="res-row">
                    <span id="stat-dt" class="status-ready">READY</span>
                    <span id="pos-dt" class="res-val">[-]</span>
                </div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-row">
                <span class="dot" style="background:#ff0"></span> Center Point (Centroid)
            </div>
            <div class="legend-row">
                <span class="grad-bar"></span> 
            </div>
            <div class="legend-row" style="justify-content: space-between; font-size:9px;">
                 <span>Collision</span>
                 <span>Boundary</span>
                 <span>Safe (Max Dist)</span>
            </div>
        </div>
    </div>

    <div id="loading">COMPUTING...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        // FFT MODULE
        // ==========================================
        const FFT = (function() {
            let _size = 0;
            let _cosTable, _sinTable, _reverseTable;

            function init(size) {
                if (_size === size) return;
                _size = size;
                _cosTable = new Float32Array(size / 2);
                _sinTable = new Float32Array(size / 2);
                _reverseTable = new Uint32Array(size);
                for (let i = 0; i < size / 2; i++) {
                    _cosTable[i] = Math.cos(-2 * Math.PI * i / size);
                    _sinTable[i] = Math.sin(-2 * Math.PI * i / size);
                }
                let limit = 1, bit = size >> 1;
                while (limit < size) {
                    for (let i = 0; i < limit; i++) _reverseTable[i + limit] = _reverseTable[i] + bit;
                    limit <<= 1; bit >>= 1;
                }
            }

            function transform(real, imag, inverse) {
                const n = _size;
                for (let i = 0; i < n; i++) {
                    const rev = _reverseTable[i];
                    if (i < rev) {
                        let t = real[i]; real[i] = real[rev]; real[rev] = t;
                        t = imag[i]; imag[i] = imag[rev]; imag[rev] = t;
                    }
                }
                let halfLen = 1;
                while (halfLen < n) {
                    const len = halfLen << 1;
                    const step = (n / len); 
                    for (let i = 0; i < n; i += len) {
                        for (let j = 0; j < halfLen; j++) {
                            const k = j * step;
                            const cos = _cosTable[k];
                            const sin = inverse ? -_sinTable[k] : _sinTable[k];
                            const idx = i + j + halfLen;
                            const tr = real[idx] * cos - imag[idx] * sin;
                            const ti = real[idx] * sin + imag[idx] * cos;
                            real[idx] = real[i + j] - tr;
                            imag[idx] = imag[i + j] - ti;
                            real[i + j] += tr;
                            imag[i + j] += ti;
                        }
                    }
                    halfLen = len;
                }
                if (inverse) {
                    const invN = 1.0 / n;
                    for (let i = 0; i < n; i++) { real[i] *= invN; imag[i] *= invN; }
                }
            }
            return { init, transform };
        })();

        // ==========================================
        // SIMULATION CLASS
        // ==========================================
        class Simulation {
            constructor() {
                this.gridSize = 256; 
                this.containerSize = 500;
                this.scale = this.gridSize / this.containerSize;
                this.obsHeight = 50; 
                
                // Buffers
                this.sizeSq = this.gridSize * this.gridSize;
                this.bufReal = new Float32Array(this.sizeSq);
                this.bufImag = new Float32Array(this.sizeSq);
                this.kernelReal = new Float32Array(this.sizeSq);
                this.kernelImag = new Float32Array(this.sizeSq);
                
                FFT.init(this.gridSize);
                this.initThreeJS();
                this.sceneComplex();
            }

            initThreeJS() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);
                this.scene.fog = new THREE.Fog(0x050505, 500, 2000);

                this.camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 10, 4000);
                this.camera.position.set(0, 900, 600);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.maxPolarAngle = Math.PI / 2 - 0.05;

                const amb = new THREE.AmbientLight(0x404040);
                this.scene.add(amb);
                const dir = new THREE.DirectionalLight(0xffffff, 1.2);
                dir.position.set(200, 800, 400);
                dir.castShadow = true;
                dir.shadow.mapSize.set(2048, 2048);
                this.scene.add(dir);

                this.containerGroup = new THREE.Group();
                this.scene.add(this.containerGroup);
                this.drawContainer();

                this.obsGroup = new THREE.Group();
                this.scene.add(this.obsGroup);
                this.resGroup = new THREE.Group();
                this.scene.add(this.resGroup);
                this.visGroup = new THREE.Group();
                this.scene.add(this.visGroup);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                const tick = () => {
                    this.controls.update();
                    this.renderer.render(this.scene, this.camera);
                    requestAnimationFrame(tick);
                };
                tick();
            }

            drawContainer() {
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(this.containerSize, this.containerSize),
                    new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.2 })
                );
                floor.rotation.x = -Math.PI/2;
                floor.receiveShadow = true;
                this.containerGroup.add(floor);

                const frameGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(this.containerSize, 200, this.containerSize));
                const frameMat = new THREE.LineBasicMaterial({ color: 0x0055aa, transparent: true, opacity: 0.3 });
                const frame = new THREE.LineSegments(frameGeo, frameMat);
                frame.position.y = 100;
                this.containerGroup.add(frame);
            }

            clearScene() {
                this.clearGroup(this.obsGroup);
                this.clearResults();
                this.obstacles = [];
            }

            clearResults() {
                this.clearGroup(this.resGroup);
                this.clearGroup(this.visGroup);
                this.resetUI();
            }

            resetUI() {
                const reset = (id) => {
                    const elStat = document.getElementById(`stat-${id}`);
                    const elPos = document.getElementById(`pos-${id}`);
                    const elTime = document.getElementById(`time-${id}`);
                    elStat.innerText = "READY";
                    elStat.className = "status-ready";
                    elPos.innerText = "[-]";
                    elTime.innerText = "0.0ms";
                }
                reset('geo');
                reset('dt');
            }

            clearGroup(group) {
                while(group.children.length){
                    const m = group.children[0];
                    if(m.geometry) m.geometry.dispose();
                    if(m.material) {
                        if(m.material.map) m.material.map.dispose();
                        m.material.dispose();
                    }
                    group.remove(m);
                }
            }

            addObstacle(x, y, w, h) {
                this.obstacles.push({x, y, w, h});
                const mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(w, this.obsHeight, h),
                    new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.9 })
                );
                mesh.position.set(x, this.obsHeight/2, y);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.obsGroup.add(mesh);
            }

            sceneComplex() {
                this.clearScene();
                const num = 14;
                for(let i=0; i<num; i++) {
                    const w = 40 + Math.random() * 50;
                    const h = 40 + Math.random() * 50;
                    const rangeX = (this.containerSize - w) / 2;
                    const rangeY = (this.containerSize - h) / 2;
                    const x = (Math.random()*2 - 1) * rangeX;
                    const y = (Math.random()*2 - 1) * rangeY;
                    this.addObstacle(x, y, w, h);
                }
            }

            sceneTight() {
                this.clearScene();
                const itemW = parseInt(document.getElementById('inputW').value);
                const gap = itemW + 4; 
                const boxW = 150;
                const boxH = 350;
                this.addObstacle(-(boxW/2 + gap/2), 0, boxW, boxH);
                this.addObstacle((boxW/2 + gap/2), 0, boxW, boxH);
                this.addObstacle(0, 200, gap + 100, 50);
            }

            updateSettings() {
                document.getElementById('dispW').innerText = document.getElementById('inputW').value + 'mm';
                document.getElementById('dispH').innerText = document.getElementById('inputH').value + 'mm';
                this.clearResults();
            }

            // ==========================================
            // CORE ALGORITHMS
            // ==========================================

            getGeoMap() {
                const size = this.gridSize;
                const map = new Float32Array(size * size).fill(0);
                const halfSize = this.containerSize / 2;

                for(const obs of this.obstacles) {
                    const minX = Math.floor((obs.x - obs.w/2 + halfSize) * this.scale);
                    const maxX = Math.ceil((obs.x + obs.w/2 + halfSize) * this.scale);
                    const minY = Math.floor((obs.y - obs.h/2 + halfSize) * this.scale);
                    const maxY = Math.ceil((obs.y + obs.h/2 + halfSize) * this.scale);
                    
                    const cMinX = Math.max(0, minX); const cMaxX = Math.min(size, maxX);
                    const cMinY = Math.max(0, minY); const cMaxY = Math.min(size, maxY);

                    for(let y=cMinY; y<cMaxY; y++) {
                        for(let x=cMinX; x<cMaxX; x++) {
                            map[y*size + x] = 1;
                        }
                    }
                }
                return map;
            }

            gridToWorld(x, y, layerZ) {
                const halfSize = this.containerSize / 2;
                const centerX = (x / this.scale) - halfSize;
                const centerY = (y / this.scale) - halfSize;
                return { x: centerX, y: centerY, z: layerZ };
            }

            // 1. Geometric Search
            runGeometric(itemW, itemH, map) {
                const start = performance.now();
                const itemGw = Math.ceil(itemW * this.scale);
                const itemGh = Math.ceil(itemH * this.scale);
                const stride = 4;
                const limitX = this.gridSize - itemGw;
                const limitY = this.gridSize - itemGh;

                if (limitX <= 0 || limitY <= 0) return { res: null, time: performance.now() - start };

                // L0
                for (let y = 0; y < limitY; y += stride) {
                    for (let x = 0; x < limitX; x += stride) {
                        if (!this.checkGeoCollision(map, x, y, itemGw, itemGh)) {
                            return { res: { ...this.gridToWorld(x + itemGw/2, y + itemGh/2, 0), w: itemW, h: itemH }, time: performance.now() - start, layer: 0 };
                        }
                    }
                }
                // L1
                for (let y = 0; y < limitY; y += stride) {
                    for (let x = 0; x < limitX; x += stride) {
                        if (this.checkGeoSupport(map, x, y, itemGw, itemGh)) {
                            return { res: { ...this.gridToWorld(x + itemGw/2, y + itemGh/2, this.obsHeight), w: itemW, h: itemH }, time: performance.now() - start, layer: 1 };
                        }
                    }
                }
                return { res: null, time: performance.now() - start };
            }

            checkGeoCollision(map, x, y, w, h) {
                const yEnd = y + h - 1; const xEnd = x + w - 1;
                if(map[y*this.gridSize+x] || map[yEnd*this.gridSize+xEnd]) return true;
                const stride = 4;
                for(let dy=0; dy<h; dy+=stride) {
                    for(let dx=0; dx<w; dx+=stride) {
                        if(map[(y+dy)*this.gridSize + (x+dx)]) return true;
                    }
                }
                return false;
            }

            checkGeoSupport(map, x, y, w, h) {
                const cx = x + Math.floor(w/2); const cy = y + Math.floor(h/2);
                if(!map[cy*this.gridSize+cx]) return false;
                const yEnd = y + h - 1; const xEnd = x + w - 1;
                if(!map[y*this.gridSize+x] || !map[yEnd*this.gridSize+xEnd]) return false;
                return true;
            }

            // 2. Hybrid Search
            runHybrid(itemW, itemH, map) {
                const start = performance.now();
                const size = this.gridSize;
                const itemGw = Math.ceil(itemW * this.scale);
                const itemGh = Math.ceil(itemH * this.scale);
                
                // Get User Strategy
                const strategy = document.querySelector('input[name="strategy"]:checked').value;

                // --- PHASE 1: FFT CONVOLUTION ---
                this.kernelReal.fill(0); this.kernelImag.fill(0);
                const halfW = Math.floor(itemGw / 2);
                const halfH = Math.floor(itemGh / 2);
                for(let dy = -halfH; dy < itemGh - halfH; dy++) {
                    for(let dx = -halfW; dx < itemGw - halfW; dx++) {
                        const idxX = (size + dx) % size;
                        const idxY = (size + dy) % size;
                        this.kernelReal[idxY*size + idxX] = 1.0;
                    }
                }
                this.fft2D(this.kernelReal, this.kernelImag, false);
                this.bufReal.set(map);
                this.bufImag.fill(0);
                this.fft2D(this.bufReal, this.bufImag, false);

                for(let i=0; i<this.sizeSq; i++) {
                    const rA = this.bufReal[i]; const iA = this.bufImag[i];
                    const rB = this.kernelReal[i]; const iB = this.kernelImag[i];
                    this.bufReal[i] = rA*rB - iA*iB;
                    this.bufImag[i] = rA*iB + iA*rB;
                }
                
                this.fft2D(this.bufReal, this.bufImag, true);

                // --- PHASE 2: Distance Transform ---
                const maxOverlap = itemGw * itemGh;
                const thresholdSafe = 0.5; 
                
                const safeMap = new Uint8Array(size * size);
                const bMinX = halfW; const bMaxX = size - halfW;
                const bMinY = halfH; const bMaxY = size - halfH;

                let hasSafeL0 = false;
                for(let y=0; y<size; y++) {
                    for(let x=0; x<size; x++) {
                        if (x >= bMinX && x < bMaxX && y >= bMinY && y < bMaxY) {
                             if (this.bufReal[y*size+x] < thresholdSafe) {
                                 safeMap[y*size+x] = 1;
                                 hasSafeL0 = true;
                             } else {
                                 safeMap[y*size+x] = 0;
                             }
                        } else {
                            safeMap[y*size+x] = 0;
                        }
                    }
                }

                let bestLayer = 0;
                let finalDT = null;
                let bestPos = { val: 0 };

                if (hasSafeL0) {
                    finalDT = this.computeEDT(safeMap, size);
                    // Select Logic based on Strategy
                    if (strategy === 'topLeft') {
                        bestPos = this.findTopLeft(finalDT, size);
                    } else {
                        bestPos = this.findMax(finalDT, size);
                    }
                }

                if (bestPos.val <= 0) {
                     const thresholdSupport = maxOverlap * 0.95;
                     const safeMapL1 = new Uint8Array(size * size);
                     for(let y=0; y<size; y++) {
                        for(let x=0; x<size; x++) {
                             if (x >= bMinX && x < bMaxX && y >= bMinY && y < bMaxY) {
                                 if (this.bufReal[y*size+x] > thresholdSupport) {
                                     safeMapL1[y*size+x] = 1;
                                 } else {
                                     safeMapL1[y*size+x] = 0;
                                 }
                             } else {
                                safeMapL1[y*size+x] = 0;
                             }
                        }
                    }
                    finalDT = this.computeEDT(safeMapL1, size);
                    if (strategy === 'topLeft') {
                        bestPos = this.findTopLeft(finalDT, size);
                    } else {
                        bestPos = this.findMax(finalDT, size);
                    }
                    bestLayer = 1;
                }

                if (bestPos.val > 0) {
                    return { 
                        res: { ...this.gridToWorld(bestPos.x, bestPos.y, bestLayer === 0 ? 0 : this.obsHeight), w: itemW, h: itemH },
                        time: performance.now() - start, 
                        dtMap: finalDT,
                        layer: bestLayer,
                        maxVal: bestPos.val
                    };
                }

                if (!finalDT) finalDT = this.computeEDT(safeMap, size);
                return { res: null, time: performance.now() - start, dtMap: finalDT, layer: 0, maxVal: 0 };
            }

            fft2D(real, imag, inv) {
                const size = this.gridSize;
                for(let y=0; y<size; y++) {
                    const off = y*size;
                    FFT.transform(real.subarray(off, off+size), imag.subarray(off, off+size), inv);
                }
                this.transpose(real, imag);
                for(let y=0; y<size; y++) {
                    const off = y*size;
                    FFT.transform(real.subarray(off, off+size), imag.subarray(off, off+size), inv);
                }
                this.transpose(real, imag);
            }

            transpose(real, imag) {
                const size = this.gridSize;
                for (let y = 0; y < size; y++) {
                    for (let x = y + 1; x < size; x++) {
                        const i = y*size+x, j = x*size+y;
                        let t = real[i]; real[i] = real[j]; real[j] = t;
                        t = imag[i]; imag[i] = imag[j]; imag[j] = t;
                    }
                }
            }

            computeEDT(grid, size) {
                const INF = size * size * 2;
                const g = new Float32Array(size * size).fill(INF);
                for (let x = 0; x < size; x++) {
                    if (grid[x] === 0) g[x] = 0; 
                    for (let y = 1; y < size; y++) {
                        const idx = y * size + x;
                        const idxUp = (y-1) * size + x;
                        g[idx] = grid[idx] === 0 ? 0 : g[idxUp] + 1;
                    }
                    for (let y = size - 2; y >= 0; y--) {
                        const idx = y * size + x;
                        const idxDown = (y+1) * size + x;
                        if (g[idxDown] + 1 < g[idx]) g[idx] = g[idxDown] + 1;
                    }
                }
                const edt = new Float32Array(size * size);
                for (let y = 0; y < size; y++) {
                    this.edt1D(g, y * size, size, edt);
                }
                for(let i=0; i<size*size; i++) edt[i] = Math.sqrt(edt[i]);
                return edt;
            }

            edt1D(src, offset, n, dst) {
                const v = new Int32Array(n);
                const z = new Float32Array(n + 1);
                let k = 0;
                v[0] = 0; z[0] = -Infinity; z[1] = Infinity;
                for (let q = 1; q < n; q++) {
                    let s = ((src[offset+q]**2 + q*q) - (src[offset+v[k]]**2 + v[k]*v[k])) / (2*q - 2*v[k]);
                    while (s <= z[k]) { k--; s = ((src[offset+q]**2 + q*q) - (src[offset+v[k]]**2 + v[k]*v[k])) / (2*q - 2*v[k]); }
                    k++; v[k] = q; z[k] = s; z[k + 1] = Infinity;
                }
                let k2 = 0;
                for (let q = 0; q < n; q++) {
                    while (z[k2 + 1] < q) k2++;
                    const dx = q - v[k2];
                    dst[offset + q] = dx * dx + src[offset + v[k2]] * src[offset + v[k2]];
                }
            }

            // Strategy: Max Safety
            findMax(map, size) {
                let maxVal = -1;
                let bestX = -1;
                let bestY = -1;
                for(let i=0; i<size*size; i++) {
                    if (map[i] > maxVal) {
                        maxVal = map[i];
                        bestX = i % size;
                        bestY = Math.floor(i / size);
                    }
                }
                return { x: bestX, y: bestY, val: maxVal };
            }

            // Strategy: Top-Left (Density)
            findTopLeft(map, size) {
                for(let i=0; i<size*size; i++) {
                    if (map[i] > 0.5) {
                        return { x: i % size, y: Math.floor(i / size), val: map[i] };
                    }
                }
                return { val: 0 };
            }

            async run() {
                const loader = document.getElementById('loading');
                loader.style.display = 'block';
                await new Promise(r => setTimeout(r, 50));
                try {
                    this.clearGroup(this.resGroup);
                    this.clearGroup(this.visGroup);
                    this.resetUI();

                    const w = parseInt(document.getElementById('inputW').value);
                    const h = parseInt(document.getElementById('inputH').value);
                    const map = this.getGeoMap(); 
                    const t0 = performance.now();
                    const geo = this.runGeometric(w, h, map);
                    const t1 = performance.now();
                    const dtRes = this.runHybrid(w, h, map);
                    const t2 = performance.now();
                    this.updateUI(geo, t1-t0, dtRes, t2-t1);
                    this.visualize(geo, dtRes);
                } catch (e) {
                    console.error("Sim Error", e);
                } finally {
                    loader.style.display = 'none';
                }
            }

            updateUI(geo, timeGeo, dt, timeDt) {
                const set = (id, res, time) => {
                    const elTime = document.getElementById(`time-${id}`);
                    const elStat = document.getElementById(`stat-${id}`);
                    const elPos = document.getElementById(`pos-${id}`);
                    if(elTime) elTime.innerText = time.toFixed(1) + 'ms';
                    if (res && res.res) {
                        const l = res.layer > 0 ? "L1" : "L0";
                        if(elStat) {
                            elStat.innerHTML = `<span class="status-ok">SUCCESS</span> <span class="layer-badge">${l}</span>`;
                            elStat.className = "";
                        }
                        if(elPos) elPos.innerText = `X:${res.res.x.toFixed(0)} Y:${res.res.y.toFixed(0)}`;
                    } else {
                        if(elStat) {
                            elStat.innerHTML = "FAILED";
                            elStat.className = "status-ng";
                        }
                        if(elPos) elPos.innerText = "[-]";
                    }
                };
                set('geo', geo, timeGeo);
                set('dt', dt, timeDt);
            }

            visualize(geo, dt) {
                if (geo.res) {
                    this.addResultBox(geo.res, 0x00ff00, 0);
                    this.addCenterPoint(geo.res, 0x00ff00, 0);
                }
                if (dt.res) {
                    this.addResultBox(dt.res, 0x0088ff, 2);
                    this.addCenterPoint(dt.res, 0xffff00, 2);
                }
                if (dt.dtMap) this.addHeatmap(dt.dtMap, dt.layer, dt.maxVal);
            }

            addResultBox(res, color, zOffset) {
                const geo = new THREE.BoxGeometry(res.w, this.obsHeight, res.h);
                const mat = new THREE.MeshPhongMaterial({ color: color, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(res.x, res.z + this.obsHeight/2 + zOffset, res.y);
                mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })));
                this.resGroup.add(mesh);
            }

            addCenterPoint(res, color, zOffset) {
                const geo = new THREE.SphereGeometry(6, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: color, depthTest: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.renderOrder = 999;
                mesh.position.set(res.x, res.z + this.obsHeight/2 + zOffset, res.y);
                this.visGroup.add(mesh);
            }

            addHeatmap(data, layer, maxVal) {
                const size = this.gridSize;
                const texData = new Uint8Array(4 * size * size);
                for(let i=0; i<size*size; i++) {
                    const val = data[i]; 
                    const stride = i * 4;
                    if (val <= 0.5) { 
                        texData[stride] = 255; texData[stride+1] = 0; texData[stride+2] = 0; texData[stride+3] = 40; 
                    } else { 
                        const norm = Math.min(1.0, val / 50.0);
                        const intensity = Math.floor(norm * 255);
                        texData[stride] = 0; texData[stride+1] = Math.floor(intensity * 0.8); texData[stride+2] = Math.max(100, intensity); texData[stride+3] = Math.max(100, intensity); 
                    }
                }
                const texture = new THREE.DataTexture(texData, size, size);
                texture.needsUpdate = true;
                const geo = new THREE.PlaneGeometry(this.containerSize, this.containerSize);
                const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI / 2; mesh.scale.y = -1; mesh.position.y = layer === 0 ? 2 : this.obsHeight + 2;
                this.visGroup.add(mesh);
            }
        }

        window.sim = new Simulation();
    </script>
</body>
</html>
